This project demonstrates a purely-hardware implementation, in Verilog, of a 90° counter-clockwise rotation on a 24-bit BMP image (e.g. the classic Lena). It is structured as a pipeline of nine distinct modules:

BMP_Preprocessor (Python)
Parses the input BMP file and dumps its pixels (RRGGBB hex) into lena.mem.

TB_InputDriver (Testbench)
Reads lena.mem and generates synchronized pixel-stream signals (Start_in, H_Valid_in, H_Jump_in, Bmp_Data) under a 100 MHz clock.

Input_Interface
Synchronizes and debounces the incoming control and data lines, producing clean pixel_valid, pixel_ready, line_end, and pixel_data.

Write_Controller (FSM)
Captures each incoming pixel and writes it sequentially into synchronous SRAM.

SRAM_Model
A behavioral 24-bit, 65 536-deep memory that holds the entire image.

Read_Controller (FSM + 2-stage pipeline)
After the write phase completes, issues read commands with a one-cycle delay and re-orders addresses so that each output pixel appears in the rotated position.

Addr_Generator
Encapsulates the core “new(r,c) = old(c, W–1–r)” mapping for counter-clockwise rotation.

Output_Interface
Formats the rotated pixel stream back into Start_out, H_Valid_out, H_Jump_out, R_Bmp_Data signals.

Top_TB (Testbench)
Instantiates all modules, collects R_Bmp_Data into an array, and dumps lena_rot.mem once 65 536 pixels are written.

A companion BMP_Postprocessor script reads lena_rot.mem and reconstructs the final lena_rot.bmp, which you can open to verify the 90° counter-clockwise rotation.

## Repository Layout

```
.
├── bmp_preprocessor.py      # Python script to convert BMP → .mem
├── bmp_postprocessor.py     # Python script to convert .mem → BMP
├── lena.bmp                 # Original 256×256 24-bit Lena image
├── lena.mem                 # Generated by bmp_preprocessor.py
├── lena_rot.mem             # Generated by ModelSim / Top_TB.v
├── lena_rot.bmp             # Generated by bmp_postprocessor.py
├── TB_InputDriver.v
├── Input_Interface.v
├── Write_Controller.v
├── SRAM_Model.v
├── Read_Controller.v
├── Addr_Generator.v
├── Output_Interface.v
└── Top_TB.v                 # Top-level testbench
```

---

## 1. Prerequisites

* **Python 3** (≥3.6)
* **ModelSim** (or your preferred IEEE-1364-2005-compliant Verilog simulator)
* `iverilog`/`vvp` (optional, for quick end-to-end CLI simulation)

---

## 2. Clone the Repository

```bash
git clone https://github.com/<your-username>/verirotate.git
cd verirotate
```

---

## 3. Generate the Memory File from `lena.bmp`

```bash
# Converts lena.bmp → lena.mem (RRGGBB hex per line)
python bmp_preprocessor.py lena.bmp lena.mem
```

* **Input:**  `lena.bmp` (24-bit BMP)
* **Output:** `lena.mem` (65 536 lines, each “RRGGBB”)

---

## 4. Run the Verilog Simulation in ModelSim

1. **Create & map the work library**

   ```tcl
   vlib work
   vmap work work
   ```

2. **Compile all design & testbench files**

   ```tcl
   vlog TB_InputDriver.v \
        Input_Interface.v \
        Write_Controller.v \
        SRAM_Model.v \
        Read_Controller.v \
        Addr_Generator.v \
        Output_Interface.v \
        Top_TB.v
   ```

3. **Load the top-level testbench**

   ```tcl
   vsim work.Top_TB
   ```

4. **Run the simulation**

   ```tcl
   run -all
   ```

   At completion you should see:

   ```
   ```

旋转完成，文件 lena\_rot.mem 已生成

````

- **Generated:** `lena_rot.mem` (rotated pixel data)  

---

## 5. Reconstruct the Rotated BMP

```bash
# Converts lena_rot.mem → lena_rot.bmp
python bmp_postprocessor.py lena.bmp lena_rot.mem lena_rot.bmp
````

* **Input:**  `lena.bmp` (header) + `lena_rot.mem` (pixel data)
* **Output:** `lena_rot.bmp` (90° CCW-rotated image)

---

## 6. Verify Results

Open `lena_rot.bmp` in your image viewer—it should appear rotated 90° counter-clockwise relative to the original.

