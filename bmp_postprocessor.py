# bmp_postprocessor.py


#!/usr/bin/env python3
"""
BMP_Postprocessor: Reconstruct a BMP image from a linearized pixel memory file.
Inputs:
  - input_bmp: Path to the original BMP file (used to copy header information).
  - input_mem: Path to the .mem file containing rotated pixel values generated by the Verilog testbench.
Output:
  - output_bmp: Path where the reconstructed rotated BMP image will be written.
"""

import sys

def postprocess_bmp(input_bmp: str, input_mem: str, output_bmp: str):
    # -------------------------------------------------------------------------
    # Read and validate the BMP header from the original file
    # -------------------------------------------------------------------------
    with open(input_bmp, 'rb') as f:
        # Read the first 54 bytes of the BMP header
        header = f.read(54)
        if len(header) != 54:
            raise ValueError("Invalid BMP header size: expected 54 bytes")
        # Data offset: where pixel array begins (bytes 10–13, little endian)
        data_offset = int.from_bytes(header[10:14], 'little')
        # Image width: bytes 18–21 (little endian)
        width = int.from_bytes(header[18:22], 'little')
        # Image height: bytes 22–25 (little endian)
        height = int.from_bytes(header[22:26], 'little')
        # Bits per pixel: bytes 28–29 (should be 24 for true-color)
        bpp = int.from_bytes(header[28:30], 'little')

    # Ensure we have a 24-bit BMP
    if bpp != 24:
        raise ValueError(f"Unsupported BMP bit depth: {bpp} (expected 24)")

    # -------------------------------------------------------------------------
    # Parse the .mem file to extract RGB tuples in top-to-bottom, left-to-right order
    # -------------------------------------------------------------------------
    pixels = []
    hex_digits = set("0123456789abcdefABCDEF")
    with open(input_mem, 'r') as f:
        for line in f:
            s = line.strip()
            # Skip blank lines, ModelSim comments ('//'), and address markers ('@')
            if not s or s.startswith('//') or s.startswith('@'):
                continue
            # Only accept lines that are exactly 6 hex characters
            if len(s) == 6 and all(c in hex_digits for c in s):
                # Convert hex string 'RRGGBB' to integer
                val = int(s, 16)
                # Extract red, green, blue channels
                r = (val >> 16) & 0xFF
                g = (val >> 8) & 0xFF
                b = val & 0xFF
                pixels.append((r, g, b))
            # All other lines are ignored

    # -------------------------------------------------------------------------
    # Calculate row padding: BMP requires each scanline to be 4-byte aligned
    # -------------------------------------------------------------------------
    # Each pixel is 3 bytes; pad each row to nearest multiple of 4 bytes
    row_size = ((width * 3 + 3) // 4) * 4
    padding = row_size - width * 3  # Number of padding bytes per scanline

    # Ensure we have exactly width*height pixels
    if len(pixels) != width * height:
        raise ValueError(f"Pixel count mismatch: expected {width*height}, got {len(pixels)}")

    # -------------------------------------------------------------------------
    # Write out the new BMP file
    # -------------------------------------------------------------------------
    with open(output_bmp, 'wb') as fout:
        # Write the original 54-byte header unchanged
        fout.write(header)
        # Seek to the pixel data offset (optional, header size already 54 bytes)
        # fout.seek(data_offset)

        # BMP stores pixel rows bottom-to-top
        for row in range(height - 1, -1, -1):
            # For each column left-to-right
            for col in range(width):
                r, g, b = pixels[row * width + col]
                # BMP pixel order is BGR
                fout.write(bytes([b, g, r]))
            # Write padding bytes at end of scanline
            fout.write(b'\x00' * padding)

    print(f"Reconstructed rotated BMP saved to: {output_bmp}")

if __name__ == "__main__":
    # Command-line interface: expect exactly 3 arguments
    if len(sys.argv) != 4:
        print("Usage: python bmp_postprocessor.py <input.bmp> <input.mem> <output.bmp>")
        sys.exit(1)
    postprocess_bmp(sys.argv[1], sys.argv[2], sys.argv[3])
